 websocketpp/connection.hpp           | 12 +++++++++++-
 websocketpp/impl/connection_impl.hpp | 34 +++++++++++++++++++++++++++++++---
 2 files changed, 42 insertions(+), 4 deletions(-)

diff --git a/websocketpp/connection.hpp b/websocketpp/connection.hpp
index d019fce..84c66f1 100644
--- a/websocketpp/connection.hpp
+++ b/websocketpp/connection.hpp
@@ -1357,6 +1357,17 @@ public:
         m_connection_hdl = hdl;
         transport_con_type::set_handle(hdl);
     }
+    void set_http(const std::string& method, const std::string& body = ""){
+        m_is_http = true;
+        m_request.set_method(method);
+        if(body.length())
+            m_request.set_body(body);
+    }
+    void set_http(bool v = true){
+        m_is_http = v;
+        if(v)
+            m_request.set_method("GET");
+    }
 protected:
     void handle_transport_init(lib::error_code const & ec);
 
@@ -1627,7 +1638,6 @@ private:
     /// A flag that gets set once it is determined that the connection is an
     /// HTTP connection and not a WebSocket one.
     bool m_is_http;
-    
     /// A flag that gets set when the completion of an http connection is
     /// deferred until later.
     session::http_state::value m_http_state;
diff --git a/websocketpp/impl/connection_impl.hpp b/websocketpp/impl/connection_impl.hpp
index bf88c95..93dd4ef 100644
--- a/websocketpp/impl/connection_impl.hpp
+++ b/websocketpp/impl/connection_impl.hpp
@@ -1440,8 +1440,16 @@ void connection<config>::send_http_request() {
     // selected client version
     if (m_processor) {
         lib::error_code ec;
-        ec = m_processor->client_handshake_request(m_request,m_uri,
-            m_requested_subprotocols);
+        if(m_is_http){
+            // m_request.set_method("GET");
+            m_request.set_uri(m_uri->get_resource());
+            m_request.set_version("HTTP/1.1");
+            m_request.replace_header("Host",m_uri->get_host_port());
+        } 
+        else {
+            ec = m_processor->client_handshake_request(m_request,m_uri,
+                m_requested_subprotocols);    
+        }
 
         if (ec) {
             log_err(log::elevel::fatal,"Internal library error: Processor",ec);
@@ -1600,7 +1608,27 @@ void connection<config>::handle_read_http_response(lib::error_code const & ec,
             m_handshake_timer->cancel();
             m_handshake_timer.reset();
         }
-
+        if(m_is_http) {
+            if(m_response.ready() || m_request.get_method() == "HEAD") {
+                if (m_http_handler)
+                    m_http_handler(m_connection_hdl);
+                this->terminate(make_error_code(error::http_connection_ended));
+            }
+			else {
+				transport_con_type::async_read_at_least(
+                        1,
+                        m_buf,
+                        config::connection_read_buffer_size,
+                        lib::bind(
+                            &type::handle_read_http_response,
+                            type::get_shared(),
+                            lib::placeholders::_1,
+                            lib::placeholders::_2
+                        )
+                    );
+			}
+			return ;
+        }
         lib::error_code validate_ec = m_processor->validate_server_handshake_response(
             m_request,
             m_response
